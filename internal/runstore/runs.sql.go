// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: runs.sql

package runstore

import (
	"context"
	"time"
)

const createRun = `-- name: CreateRun :one
INSERT into runs (
	date, 
	distance, 
	runtime,
	type,
	name
) values (
	$1,$2,$3,$4,$5
	)
	returning date, distance, runtime, type, name
`

type CreateRunParams struct {
	Date     time.Time `json:"date"`
	Distance float64   `json:"distance"`
	Runtime  int32     `json:"runtime"`
	Type     string    `json:"type"`
	Name     string    `json:"name"`
}

func (q *Queries) CreateRun(ctx context.Context, arg CreateRunParams) (Run, error) {
	row := q.db.QueryRow(ctx, createRun,
		arg.Date,
		arg.Distance,
		arg.Runtime,
		arg.Type,
		arg.Name,
	)
	var i Run
	err := row.Scan(
		&i.Date,
		&i.Distance,
		&i.Runtime,
		&i.Type,
		&i.Name,
	)
	return i, err
}

const getLastRun = `-- name: GetLastRun :one
SELECT date, distance, runtime, type, name FROM runs ORDER BY date DESC LIMIT 1
`

func (q *Queries) GetLastRun(ctx context.Context) (Run, error) {
	row := q.db.QueryRow(ctx, getLastRun)
	var i Run
	err := row.Scan(
		&i.Date,
		&i.Distance,
		&i.Runtime,
		&i.Type,
		&i.Name,
	)
	return i, err
}

const getRuns = `-- name: GetRuns :many
SELECT date, distance, runtime, type, name FROM runs LIMIT 10
`

func (q *Queries) GetRuns(ctx context.Context) ([]Run, error) {
	rows, err := q.db.Query(ctx, getRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.Date,
			&i.Distance,
			&i.Runtime,
			&i.Type,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
