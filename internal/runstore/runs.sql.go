// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: runs.sql

package runstore

import (
	"context"
	"time"
)

const createRun = `-- name: CreateRun :one
INSERT into runs (
	date, 
	distance, 
	runtime
) values (
	$1,$2,$3
	)
	returning date, distance, runtime
`

type CreateRunParams struct {
	Date     time.Time `json:"date"`
	Distance float64   `json:"distance"`
	Runtime  int32     `json:"runtime"`
}

func (q *Queries) CreateRun(ctx context.Context, arg CreateRunParams) (Run, error) {
	row := q.db.QueryRow(ctx, createRun, arg.Date, arg.Distance, arg.Runtime)
	var i Run
	err := row.Scan(&i.Date, &i.Distance, &i.Runtime)
	return i, err
}

const getLastRun = `-- name: GetLastRun :one
SELECT date, distance, runtime FROM runs ORDER BY date DESC LIMIT 1
`

func (q *Queries) GetLastRun(ctx context.Context) (Run, error) {
	row := q.db.QueryRow(ctx, getLastRun)
	var i Run
	err := row.Scan(&i.Date, &i.Distance, &i.Runtime)
	return i, err
}

const getRuns = `-- name: GetRuns :many
SELECT date, distance, runtime FROM runs LIMIT 10
`

func (q *Queries) GetRuns(ctx context.Context) ([]Run, error) {
	rows, err := q.db.Query(ctx, getRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(&i.Date, &i.Distance, &i.Runtime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
